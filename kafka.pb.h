// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kafka.proto

#ifndef PROTOBUF_INCLUDED_kafka_2eproto
#define PROTOBUF_INCLUDED_kafka_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_kafka_2eproto 

namespace protobuf_kafka_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_kafka_2eproto
namespace KafkaConsumerServer {
class BatchInfo;
class BatchInfoDefaultTypeInternal;
extern BatchInfoDefaultTypeInternal _BatchInfo_default_instance_;
class ConsumerJob;
class ConsumerJobDefaultTypeInternal;
extern ConsumerJobDefaultTypeInternal _ConsumerJob_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class JobID;
class JobIDDefaultTypeInternal;
extern JobIDDefaultTypeInternal _JobID_default_instance_;
class KafkaMessage;
class KafkaMessageDefaultTypeInternal;
extern KafkaMessageDefaultTypeInternal _KafkaMessage_default_instance_;
class KeyMessage;
class KeyMessageDefaultTypeInternal;
extern KeyMessageDefaultTypeInternal _KeyMessage_default_instance_;
class KeyValueData;
class KeyValueDataDefaultTypeInternal;
extern KeyValueDataDefaultTypeInternal _KeyValueData_default_instance_;
class ValueMessage;
class ValueMessageDefaultTypeInternal;
extern ValueMessageDefaultTypeInternal _ValueMessage_default_instance_;
}  // namespace KafkaConsumerServer
namespace google {
namespace protobuf {
template<> ::KafkaConsumerServer::BatchInfo* Arena::CreateMaybeMessage<::KafkaConsumerServer::BatchInfo>(Arena*);
template<> ::KafkaConsumerServer::ConsumerJob* Arena::CreateMaybeMessage<::KafkaConsumerServer::ConsumerJob>(Arena*);
template<> ::KafkaConsumerServer::Empty* Arena::CreateMaybeMessage<::KafkaConsumerServer::Empty>(Arena*);
template<> ::KafkaConsumerServer::JobID* Arena::CreateMaybeMessage<::KafkaConsumerServer::JobID>(Arena*);
template<> ::KafkaConsumerServer::KafkaMessage* Arena::CreateMaybeMessage<::KafkaConsumerServer::KafkaMessage>(Arena*);
template<> ::KafkaConsumerServer::KeyMessage* Arena::CreateMaybeMessage<::KafkaConsumerServer::KeyMessage>(Arena*);
template<> ::KafkaConsumerServer::KeyValueData* Arena::CreateMaybeMessage<::KafkaConsumerServer::KeyValueData>(Arena*);
template<> ::KafkaConsumerServer::ValueMessage* Arena::CreateMaybeMessage<::KafkaConsumerServer::ValueMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace KafkaConsumerServer {

// ===================================================================

class ConsumerJob : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KafkaConsumerServer.ConsumerJob) */ {
 public:
  ConsumerJob();
  virtual ~ConsumerJob();

  ConsumerJob(const ConsumerJob& from);

  inline ConsumerJob& operator=(const ConsumerJob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConsumerJob(ConsumerJob&& from) noexcept
    : ConsumerJob() {
    *this = ::std::move(from);
  }

  inline ConsumerJob& operator=(ConsumerJob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsumerJob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConsumerJob* internal_default_instance() {
    return reinterpret_cast<const ConsumerJob*>(
               &_ConsumerJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ConsumerJob* other);
  friend void swap(ConsumerJob& a, ConsumerJob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConsumerJob* New() const final {
    return CreateMaybeMessage<ConsumerJob>(NULL);
  }

  ConsumerJob* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConsumerJob>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConsumerJob& from);
  void MergeFrom(const ConsumerJob& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsumerJob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // string Brokers = 2;
  void clear_brokers();
  static const int kBrokersFieldNumber = 2;
  const ::std::string& brokers() const;
  void set_brokers(const ::std::string& value);
  #if LANG_CXX11
  void set_brokers(::std::string&& value);
  #endif
  void set_brokers(const char* value);
  void set_brokers(const char* value, size_t size);
  ::std::string* mutable_brokers();
  ::std::string* release_brokers();
  void set_allocated_brokers(::std::string* brokers);

  // string Destination = 8;
  void clear_destination();
  static const int kDestinationFieldNumber = 8;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // string Format = 9;
  void clear_format();
  static const int kFormatFieldNumber = 9;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // int64 Offset = 4;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // int32 PartitionID = 3;
  void clear_partitionid();
  static const int kPartitionIDFieldNumber = 3;
  ::google::protobuf::int32 partitionid() const;
  void set_partitionid(::google::protobuf::int32 value);

  // int32 BatchInterval = 5;
  void clear_batchinterval();
  static const int kBatchIntervalFieldNumber = 5;
  ::google::protobuf::int32 batchinterval() const;
  void set_batchinterval(::google::protobuf::int32 value);

  // int32 BatchSize = 6;
  void clear_batchsize();
  static const int kBatchSizeFieldNumber = 6;
  ::google::protobuf::int32 batchsize() const;
  void set_batchsize(::google::protobuf::int32 value);

  // int32 QueueSize = 7;
  void clear_queuesize();
  static const int kQueueSizeFieldNumber = 7;
  ::google::protobuf::int32 queuesize() const;
  void set_queuesize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:KafkaConsumerServer.ConsumerJob)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr brokers_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int32 partitionid_;
  ::google::protobuf::int32 batchinterval_;
  ::google::protobuf::int32 batchsize_;
  ::google::protobuf::int32 queuesize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kafka_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JobID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KafkaConsumerServer.JobID) */ {
 public:
  JobID();
  virtual ~JobID();

  JobID(const JobID& from);

  inline JobID& operator=(const JobID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JobID(JobID&& from) noexcept
    : JobID() {
    *this = ::std::move(from);
  }

  inline JobID& operator=(JobID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JobID* internal_default_instance() {
    return reinterpret_cast<const JobID*>(
               &_JobID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(JobID* other);
  friend void swap(JobID& a, JobID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JobID* New() const final {
    return CreateMaybeMessage<JobID>(NULL);
  }

  JobID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JobID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JobID& from);
  void MergeFrom(const JobID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:KafkaConsumerServer.JobID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kafka_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KafkaConsumerServer.KeyMessage) */ {
 public:
  KeyMessage();
  virtual ~KeyMessage();

  KeyMessage(const KeyMessage& from);

  inline KeyMessage& operator=(const KeyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyMessage(KeyMessage&& from) noexcept
    : KeyMessage() {
    *this = ::std::move(from);
  }

  inline KeyMessage& operator=(KeyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyMessage* internal_default_instance() {
    return reinterpret_cast<const KeyMessage*>(
               &_KeyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(KeyMessage* other);
  friend void swap(KeyMessage& a, KeyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyMessage* New() const final {
    return CreateMaybeMessage<KeyMessage>(NULL);
  }

  KeyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyMessage& from);
  void MergeFrom(const KeyMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes Data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data(int index) const;
  ::std::string* mutable_data(int index);
  void set_data(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_data(int index, ::std::string&& value);
  #endif
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  ::std::string* add_data();
  void add_data(const ::std::string& value);
  #if LANG_CXX11
  void add_data(::std::string&& value);
  #endif
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:KafkaConsumerServer.KeyMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kafka_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValueMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KafkaConsumerServer.ValueMessage) */ {
 public:
  ValueMessage();
  virtual ~ValueMessage();

  ValueMessage(const ValueMessage& from);

  inline ValueMessage& operator=(const ValueMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValueMessage(ValueMessage&& from) noexcept
    : ValueMessage() {
    *this = ::std::move(from);
  }

  inline ValueMessage& operator=(ValueMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValueMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValueMessage* internal_default_instance() {
    return reinterpret_cast<const ValueMessage*>(
               &_ValueMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ValueMessage* other);
  friend void swap(ValueMessage& a, ValueMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValueMessage* New() const final {
    return CreateMaybeMessage<ValueMessage>(NULL);
  }

  ValueMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValueMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ValueMessage& from);
  void MergeFrom(const ValueMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes Data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data(int index) const;
  ::std::string* mutable_data(int index);
  void set_data(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_data(int index, ::std::string&& value);
  #endif
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  ::std::string* add_data();
  void add_data(const ::std::string& value);
  #if LANG_CXX11
  void add_data(::std::string&& value);
  #endif
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:KafkaConsumerServer.ValueMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kafka_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValueData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KafkaConsumerServer.KeyValueData) */ {
 public:
  KeyValueData();
  virtual ~KeyValueData();

  KeyValueData(const KeyValueData& from);

  inline KeyValueData& operator=(const KeyValueData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValueData(KeyValueData&& from) noexcept
    : KeyValueData() {
    *this = ::std::move(from);
  }

  inline KeyValueData& operator=(KeyValueData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValueData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValueData* internal_default_instance() {
    return reinterpret_cast<const KeyValueData*>(
               &_KeyValueData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(KeyValueData* other);
  friend void swap(KeyValueData& a, KeyValueData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValueData* New() const final {
    return CreateMaybeMessage<KeyValueData>(NULL);
  }

  KeyValueData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyValueData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyValueData& from);
  void MergeFrom(const KeyValueData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes Key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes Value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:KafkaConsumerServer.KeyValueData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kafka_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KafkaMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KafkaConsumerServer.KafkaMessage) */ {
 public:
  KafkaMessage();
  virtual ~KafkaMessage();

  KafkaMessage(const KafkaMessage& from);

  inline KafkaMessage& operator=(const KafkaMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KafkaMessage(KafkaMessage&& from) noexcept
    : KafkaMessage() {
    *this = ::std::move(from);
  }

  inline KafkaMessage& operator=(KafkaMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KafkaMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KafkaMessage* internal_default_instance() {
    return reinterpret_cast<const KafkaMessage*>(
               &_KafkaMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(KafkaMessage* other);
  friend void swap(KafkaMessage& a, KafkaMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KafkaMessage* New() const final {
    return CreateMaybeMessage<KafkaMessage>(NULL);
  }

  KafkaMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KafkaMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KafkaMessage& from);
  void MergeFrom(const KafkaMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KafkaMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KafkaConsumerServer.KeyValueData Data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::KafkaConsumerServer::KeyValueData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::KafkaConsumerServer::KeyValueData >*
      mutable_data();
  const ::KafkaConsumerServer::KeyValueData& data(int index) const;
  ::KafkaConsumerServer::KeyValueData* add_data();
  const ::google::protobuf::RepeatedPtrField< ::KafkaConsumerServer::KeyValueData >&
      data() const;

  // @@protoc_insertion_point(class_scope:KafkaConsumerServer.KafkaMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KafkaConsumerServer::KeyValueData > data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kafka_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KafkaConsumerServer.BatchInfo) */ {
 public:
  BatchInfo();
  virtual ~BatchInfo();

  BatchInfo(const BatchInfo& from);

  inline BatchInfo& operator=(const BatchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchInfo(BatchInfo&& from) noexcept
    : BatchInfo() {
    *this = ::std::move(from);
  }

  inline BatchInfo& operator=(BatchInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchInfo* internal_default_instance() {
    return reinterpret_cast<const BatchInfo*>(
               &_BatchInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BatchInfo* other);
  friend void swap(BatchInfo& a, BatchInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchInfo* New() const final {
    return CreateMaybeMessage<BatchInfo>(NULL);
  }

  BatchInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BatchInfo& from);
  void MergeFrom(const BatchInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ErrorMessage = 4;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 4;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  #if LANG_CXX11
  void set_errormessage(::std::string&& value);
  #endif
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // int64 LastOffset = 1;
  void clear_lastoffset();
  static const int kLastOffsetFieldNumber = 1;
  ::google::protobuf::int64 lastoffset() const;
  void set_lastoffset(::google::protobuf::int64 value);

  // bool EOF = 2;
  void clear_eof();
  static const int kEOFFieldNumber = 2;
  bool eof() const;
  void set_eof(bool value);

  // int32 ErrorCode = 3;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 3;
  ::google::protobuf::int32 errorcode() const;
  void set_errorcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:KafkaConsumerServer.BatchInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  ::google::protobuf::int64 lastoffset_;
  bool eof_;
  ::google::protobuf::int32 errorcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kafka_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KafkaConsumerServer.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:KafkaConsumerServer.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kafka_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConsumerJob

// string Topic = 1;
inline void ConsumerJob::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConsumerJob::topic() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.Topic)
  return topic_.GetNoArena();
}
inline void ConsumerJob::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.Topic)
}
#if LANG_CXX11
inline void ConsumerJob::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KafkaConsumerServer.ConsumerJob.Topic)
}
#endif
inline void ConsumerJob::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.ConsumerJob.Topic)
}
inline void ConsumerJob::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.ConsumerJob.Topic)
}
inline ::std::string* ConsumerJob::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.ConsumerJob.Topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConsumerJob::release_topic() {
  // @@protoc_insertion_point(field_release:KafkaConsumerServer.ConsumerJob.Topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsumerJob::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:KafkaConsumerServer.ConsumerJob.Topic)
}

// string Brokers = 2;
inline void ConsumerJob::clear_brokers() {
  brokers_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConsumerJob::brokers() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.Brokers)
  return brokers_.GetNoArena();
}
inline void ConsumerJob::set_brokers(const ::std::string& value) {
  
  brokers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.Brokers)
}
#if LANG_CXX11
inline void ConsumerJob::set_brokers(::std::string&& value) {
  
  brokers_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KafkaConsumerServer.ConsumerJob.Brokers)
}
#endif
inline void ConsumerJob::set_brokers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  brokers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.ConsumerJob.Brokers)
}
inline void ConsumerJob::set_brokers(const char* value, size_t size) {
  
  brokers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.ConsumerJob.Brokers)
}
inline ::std::string* ConsumerJob::mutable_brokers() {
  
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.ConsumerJob.Brokers)
  return brokers_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConsumerJob::release_brokers() {
  // @@protoc_insertion_point(field_release:KafkaConsumerServer.ConsumerJob.Brokers)
  
  return brokers_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsumerJob::set_allocated_brokers(::std::string* brokers) {
  if (brokers != NULL) {
    
  } else {
    
  }
  brokers_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), brokers);
  // @@protoc_insertion_point(field_set_allocated:KafkaConsumerServer.ConsumerJob.Brokers)
}

// int32 PartitionID = 3;
inline void ConsumerJob::clear_partitionid() {
  partitionid_ = 0;
}
inline ::google::protobuf::int32 ConsumerJob::partitionid() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.PartitionID)
  return partitionid_;
}
inline void ConsumerJob::set_partitionid(::google::protobuf::int32 value) {
  
  partitionid_ = value;
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.PartitionID)
}

// int64 Offset = 4;
inline void ConsumerJob::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ConsumerJob::offset() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.Offset)
  return offset_;
}
inline void ConsumerJob::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.Offset)
}

// int32 BatchInterval = 5;
inline void ConsumerJob::clear_batchinterval() {
  batchinterval_ = 0;
}
inline ::google::protobuf::int32 ConsumerJob::batchinterval() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.BatchInterval)
  return batchinterval_;
}
inline void ConsumerJob::set_batchinterval(::google::protobuf::int32 value) {
  
  batchinterval_ = value;
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.BatchInterval)
}

// int32 BatchSize = 6;
inline void ConsumerJob::clear_batchsize() {
  batchsize_ = 0;
}
inline ::google::protobuf::int32 ConsumerJob::batchsize() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.BatchSize)
  return batchsize_;
}
inline void ConsumerJob::set_batchsize(::google::protobuf::int32 value) {
  
  batchsize_ = value;
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.BatchSize)
}

// int32 QueueSize = 7;
inline void ConsumerJob::clear_queuesize() {
  queuesize_ = 0;
}
inline ::google::protobuf::int32 ConsumerJob::queuesize() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.QueueSize)
  return queuesize_;
}
inline void ConsumerJob::set_queuesize(::google::protobuf::int32 value) {
  
  queuesize_ = value;
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.QueueSize)
}

// string Destination = 8;
inline void ConsumerJob::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConsumerJob::destination() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.Destination)
  return destination_.GetNoArena();
}
inline void ConsumerJob::set_destination(const ::std::string& value) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.Destination)
}
#if LANG_CXX11
inline void ConsumerJob::set_destination(::std::string&& value) {
  
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KafkaConsumerServer.ConsumerJob.Destination)
}
#endif
inline void ConsumerJob::set_destination(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.ConsumerJob.Destination)
}
inline void ConsumerJob::set_destination(const char* value, size_t size) {
  
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.ConsumerJob.Destination)
}
inline ::std::string* ConsumerJob::mutable_destination() {
  
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.ConsumerJob.Destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConsumerJob::release_destination() {
  // @@protoc_insertion_point(field_release:KafkaConsumerServer.ConsumerJob.Destination)
  
  return destination_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsumerJob::set_allocated_destination(::std::string* destination) {
  if (destination != NULL) {
    
  } else {
    
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:KafkaConsumerServer.ConsumerJob.Destination)
}

// string Format = 9;
inline void ConsumerJob::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConsumerJob::format() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ConsumerJob.Format)
  return format_.GetNoArena();
}
inline void ConsumerJob::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ConsumerJob.Format)
}
#if LANG_CXX11
inline void ConsumerJob::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KafkaConsumerServer.ConsumerJob.Format)
}
#endif
inline void ConsumerJob::set_format(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.ConsumerJob.Format)
}
inline void ConsumerJob::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.ConsumerJob.Format)
}
inline ::std::string* ConsumerJob::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.ConsumerJob.Format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConsumerJob::release_format() {
  // @@protoc_insertion_point(field_release:KafkaConsumerServer.ConsumerJob.Format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsumerJob::set_allocated_format(::std::string* format) {
  if (format != NULL) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:KafkaConsumerServer.ConsumerJob.Format)
}

// -------------------------------------------------------------------

// JobID

// string ID = 1;
inline void JobID::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JobID::id() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.JobID.ID)
  return id_.GetNoArena();
}
inline void JobID::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.JobID.ID)
}
#if LANG_CXX11
inline void JobID::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KafkaConsumerServer.JobID.ID)
}
#endif
inline void JobID::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.JobID.ID)
}
inline void JobID::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.JobID.ID)
}
inline ::std::string* JobID::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.JobID.ID)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JobID::release_id() {
  // @@protoc_insertion_point(field_release:KafkaConsumerServer.JobID.ID)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JobID::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:KafkaConsumerServer.JobID.ID)
}

// -------------------------------------------------------------------

// KeyMessage

// repeated bytes Data = 1;
inline int KeyMessage::data_size() const {
  return data_.size();
}
inline void KeyMessage::clear_data() {
  data_.Clear();
}
inline const ::std::string& KeyMessage::data(int index) const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.KeyMessage.Data)
  return data_.Get(index);
}
inline ::std::string* KeyMessage::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.KeyMessage.Data)
  return data_.Mutable(index);
}
inline void KeyMessage::set_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.KeyMessage.Data)
  data_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KeyMessage::set_data(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.KeyMessage.Data)
  data_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KeyMessage::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.KeyMessage.Data)
}
inline void KeyMessage::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.KeyMessage.Data)
}
inline ::std::string* KeyMessage::add_data() {
  // @@protoc_insertion_point(field_add_mutable:KafkaConsumerServer.KeyMessage.Data)
  return data_.Add();
}
inline void KeyMessage::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KafkaConsumerServer.KeyMessage.Data)
}
#if LANG_CXX11
inline void KeyMessage::add_data(::std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:KafkaConsumerServer.KeyMessage.Data)
}
#endif
inline void KeyMessage::add_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KafkaConsumerServer.KeyMessage.Data)
}
inline void KeyMessage::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KafkaConsumerServer.KeyMessage.Data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KeyMessage::data() const {
  // @@protoc_insertion_point(field_list:KafkaConsumerServer.KeyMessage.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KeyMessage::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:KafkaConsumerServer.KeyMessage.Data)
  return &data_;
}

// -------------------------------------------------------------------

// ValueMessage

// repeated bytes Data = 1;
inline int ValueMessage::data_size() const {
  return data_.size();
}
inline void ValueMessage::clear_data() {
  data_.Clear();
}
inline const ::std::string& ValueMessage::data(int index) const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.ValueMessage.Data)
  return data_.Get(index);
}
inline ::std::string* ValueMessage::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.ValueMessage.Data)
  return data_.Mutable(index);
}
inline void ValueMessage::set_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ValueMessage.Data)
  data_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ValueMessage::set_data(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.ValueMessage.Data)
  data_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ValueMessage::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.ValueMessage.Data)
}
inline void ValueMessage::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.ValueMessage.Data)
}
inline ::std::string* ValueMessage::add_data() {
  // @@protoc_insertion_point(field_add_mutable:KafkaConsumerServer.ValueMessage.Data)
  return data_.Add();
}
inline void ValueMessage::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KafkaConsumerServer.ValueMessage.Data)
}
#if LANG_CXX11
inline void ValueMessage::add_data(::std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:KafkaConsumerServer.ValueMessage.Data)
}
#endif
inline void ValueMessage::add_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KafkaConsumerServer.ValueMessage.Data)
}
inline void ValueMessage::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KafkaConsumerServer.ValueMessage.Data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ValueMessage::data() const {
  // @@protoc_insertion_point(field_list:KafkaConsumerServer.ValueMessage.Data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ValueMessage::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:KafkaConsumerServer.ValueMessage.Data)
  return &data_;
}

// -------------------------------------------------------------------

// KeyValueData

// bytes Key = 1;
inline void KeyValueData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValueData::key() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.KeyValueData.Key)
  return key_.GetNoArena();
}
inline void KeyValueData::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.KeyValueData.Key)
}
#if LANG_CXX11
inline void KeyValueData::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KafkaConsumerServer.KeyValueData.Key)
}
#endif
inline void KeyValueData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.KeyValueData.Key)
}
inline void KeyValueData::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.KeyValueData.Key)
}
inline ::std::string* KeyValueData::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.KeyValueData.Key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValueData::release_key() {
  // @@protoc_insertion_point(field_release:KafkaConsumerServer.KeyValueData.Key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValueData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:KafkaConsumerServer.KeyValueData.Key)
}

// bytes Value = 2;
inline void KeyValueData::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValueData::value() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.KeyValueData.Value)
  return value_.GetNoArena();
}
inline void KeyValueData::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.KeyValueData.Value)
}
#if LANG_CXX11
inline void KeyValueData::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KafkaConsumerServer.KeyValueData.Value)
}
#endif
inline void KeyValueData::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.KeyValueData.Value)
}
inline void KeyValueData::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.KeyValueData.Value)
}
inline ::std::string* KeyValueData::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.KeyValueData.Value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValueData::release_value() {
  // @@protoc_insertion_point(field_release:KafkaConsumerServer.KeyValueData.Value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValueData::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:KafkaConsumerServer.KeyValueData.Value)
}

// -------------------------------------------------------------------

// KafkaMessage

// repeated .KafkaConsumerServer.KeyValueData Data = 1;
inline int KafkaMessage::data_size() const {
  return data_.size();
}
inline void KafkaMessage::clear_data() {
  data_.Clear();
}
inline ::KafkaConsumerServer::KeyValueData* KafkaMessage::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.KafkaMessage.Data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KafkaConsumerServer::KeyValueData >*
KafkaMessage::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:KafkaConsumerServer.KafkaMessage.Data)
  return &data_;
}
inline const ::KafkaConsumerServer::KeyValueData& KafkaMessage::data(int index) const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.KafkaMessage.Data)
  return data_.Get(index);
}
inline ::KafkaConsumerServer::KeyValueData* KafkaMessage::add_data() {
  // @@protoc_insertion_point(field_add:KafkaConsumerServer.KafkaMessage.Data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KafkaConsumerServer::KeyValueData >&
KafkaMessage::data() const {
  // @@protoc_insertion_point(field_list:KafkaConsumerServer.KafkaMessage.Data)
  return data_;
}

// -------------------------------------------------------------------

// BatchInfo

// int64 LastOffset = 1;
inline void BatchInfo::clear_lastoffset() {
  lastoffset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BatchInfo::lastoffset() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.BatchInfo.LastOffset)
  return lastoffset_;
}
inline void BatchInfo::set_lastoffset(::google::protobuf::int64 value) {
  
  lastoffset_ = value;
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.BatchInfo.LastOffset)
}

// bool EOF = 2;
inline void BatchInfo::clear_eof() {
  eof_ = false;
}
inline bool BatchInfo::eof() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.BatchInfo.EOF)
  return eof_;
}
inline void BatchInfo::set_eof(bool value) {
  
  eof_ = value;
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.BatchInfo.EOF)
}

// int32 ErrorCode = 3;
inline void BatchInfo::clear_errorcode() {
  errorcode_ = 0;
}
inline ::google::protobuf::int32 BatchInfo::errorcode() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.BatchInfo.ErrorCode)
  return errorcode_;
}
inline void BatchInfo::set_errorcode(::google::protobuf::int32 value) {
  
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.BatchInfo.ErrorCode)
}

// string ErrorMessage = 4;
inline void BatchInfo::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BatchInfo::errormessage() const {
  // @@protoc_insertion_point(field_get:KafkaConsumerServer.BatchInfo.ErrorMessage)
  return errormessage_.GetNoArena();
}
inline void BatchInfo::set_errormessage(const ::std::string& value) {
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KafkaConsumerServer.BatchInfo.ErrorMessage)
}
#if LANG_CXX11
inline void BatchInfo::set_errormessage(::std::string&& value) {
  
  errormessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KafkaConsumerServer.BatchInfo.ErrorMessage)
}
#endif
inline void BatchInfo::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KafkaConsumerServer.BatchInfo.ErrorMessage)
}
inline void BatchInfo::set_errormessage(const char* value, size_t size) {
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KafkaConsumerServer.BatchInfo.ErrorMessage)
}
inline ::std::string* BatchInfo::mutable_errormessage() {
  
  // @@protoc_insertion_point(field_mutable:KafkaConsumerServer.BatchInfo.ErrorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BatchInfo::release_errormessage() {
  // @@protoc_insertion_point(field_release:KafkaConsumerServer.BatchInfo.ErrorMessage)
  
  return errormessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchInfo::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    
  } else {
    
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:KafkaConsumerServer.BatchInfo.ErrorMessage)
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace KafkaConsumerServer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_kafka_2eproto
